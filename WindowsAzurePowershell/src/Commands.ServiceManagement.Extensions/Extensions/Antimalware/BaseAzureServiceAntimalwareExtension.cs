// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------------------------------------------------------------

namespace Microsoft.WindowsAzure.Commands.ServiceManagement.Extensions
{
    using Management.Storage;
    using Model.PersistentVMModel;
    using Properties;
    using System;
    using System.Linq;
    using System.Management.Automation;
    using System.Text;
    using System.Xml;
    using System.Xml.Linq;
    using Utilities.Common;
    using Management.Compute.Models;

    public abstract class BaseAzureServiceAntimalwareExtensionCmdlet : BaseAzureServiceExtensionCmdlet
    {
        // this cmdlet sets the antimalware extension that the user requests to enable and use via config setting
        // if monitoring is set to "on", the diagnostics extension will also configure monitoring of antimalware event data

        // shared
        protected ExtensionConfigurationInput AntimalwareExtensionConfigurationInput { get; set; }
        protected ExtensionConfigurationInput AntimalwareMonitoringExtensionConfigurationInput { get; set; }

        // antimalware
        protected const string AntimalwareConfigElementName = "AntimalwareConfig";
        protected const string AntimalwareExtensionProviderNamespace = "Microsoft.Azure.Security";
        protected const string AntimalwareExtensionName = "PaaSAntimalware";
        public virtual XmlDocument AntimalwareConfiguration { get; set; }

        // diagnostics
        protected const string StorageAccountElemStr = "StorageAccount";
        protected const string AntimalwareDiagnosticsExtensionNamespace = "Microsoft.Azure.Diagnostics";
        protected const string AntimalwareDiagnosticsExtensionName = "PaaSDiagnostics";
        protected const string DiagnosticsConfigXmlNamespace = @"http://schemas.microsoft.com/ServiceHosting/2010/10/DiagnosticsConfiguration";
        protected const string DiagnosticsConfigElementName = "WadCfg";
        protected const string DiagnosticsConfigNodeName = "DiagnosticMonitorConfiguration";
        protected const string DiagnosticsConfigAntimalwareProviderToken = @"Microsoft Antimalware";
        protected const string DiagnosticsConfigWindowsEventLogNodeName = @"WindowsEventLog";
        protected const string StorageNameAttrStr = "name";

        protected const string DiagnosticsDefaultConfigNewXmlStr = @"<DiagnosticMonitorConfiguration><WindowsEventLog scheduledTransferPeriod=""PT1M""><DataSource name=""System!*[System[Provider[@Name='Microsoft Antimalware']]]"" /></WindowsEventLog></DiagnosticMonitorConfiguration>";
        protected const string DiagnosticsDefaultConfigMergeXmlWithoutExistingEventLogNode = @"<WindowsEventLog scheduledTransferPeriod=""PT1M""><DataSource name=""System!*[System[Provider[@Name='Microsoft Antimalware']]]"" /></WindowsEventLog>";
        protected const string DiagnosticsDefaultConfigMergeXmlWithExistingEventLogNode = @"<DataSource name=""System!*[System[Provider[@Name='Microsoft Antimalware']]]"" />";
        public virtual XmlDocument AntimalwareMonitoringConfig { get; set; }

        protected string StorageKey { get; set; }
        protected string ConnectionQualifiers { get; set; }
        protected string DefaultEndpointsProtocol { get; set; }
        public virtual string StorageAccountName { get; set; }
        public virtual string StorageEndpointSuffix { get; set; }

        public BaseAzureServiceAntimalwareExtensionCmdlet()
            : base()
        {
        }

        protected void InitializeAntimalwareSettings()
        {
            ProviderNamespace = AntimalwareExtensionProviderNamespace;
            ExtensionName = AntimalwareExtensionName;

            // public configuration 
            if (AntimalwareConfiguration != null)
            {
                PublicConfiguration = AntimalwareConfiguration.OuterXml;
            }
            else
            {
                PublicConfiguration = null;
            }
        }

        protected void InitializeDiagnosticsSettings()
        {
            ProviderNamespace = AntimalwareDiagnosticsExtensionNamespace;
            ExtensionName = AntimalwareDiagnosticsExtensionName;

            // public configuration 
            XNamespace configNameSpace = DiagnosticsConfigXmlNamespace;
            PublicConfigurationXml = new XDocument(
                new XDeclaration("1.0", "utf-8", null),
                    new XElement(configNameSpace + PublicConfigStr,
                        new XElement(configNameSpace + DiagnosticsConfigElementName, string.Empty),
                        new XElement(configNameSpace + StorageAccountElemStr, StorageAccountName)
                )
            );

            if (AntimalwareMonitoringConfig == null)
            {
                XmlDocument amCfgXmlDoc = new XmlDocument();
                amCfgXmlDoc.LoadXml(DiagnosticsDefaultConfigNewXmlStr);
                AntimalwareMonitoringConfig = amCfgXmlDoc;
            }

            SetPublicConfigValue(DiagnosticsConfigElementName, AntimalwareMonitoringConfig);
            PublicConfiguration = PublicConfigurationXml.ToString();

            // add storage account name to private configuration if applicable
            if (string.IsNullOrEmpty(StorageEndpointSuffix))
            {
                PrivateConfigurationXml = new XDocument(
                    new XDeclaration("1.0", "utf-8", null),
                    new XElement(configNameSpace + PrivateConfigStr,
                        new XElement(configNameSpace + StorageAccountElemStr,
                        new XAttribute("name", StorageAccountName),
                        new XAttribute("key", StorageKey)
                    ))
                );
            }
            else
            {
                // provide custom endpoint suffix to diagnostics extension
                PrivateConfigurationXml = new XDocument(
                    new XDeclaration("1.0", "utf-8", null),
                    new XElement(configNameSpace + PrivateConfigStr,
                        new XElement(configNameSpace + StorageAccountElemStr,
                        new XAttribute("name", StorageAccountName),
                        new XAttribute("key", StorageKey),
                        new XAttribute("endpoint", StorageEndpointSuffix)
                    ))
                );
            }
            PrivateConfiguration = PrivateConfigurationXml.ToString();
        }

        protected void ValidateStorageAccount()
        {
            var storageService = this.StorageClient.StorageAccounts.Get(StorageAccountName);
            if (storageService == null)
            {
                throw new Exception(string.Format(Resources.ServiceExtensionCannotFindStorageAccountName, StorageAccountName));
            }

            var storageKeys = this.StorageClient.StorageAccounts.GetKeys(storageService.StorageAccount.Name);
            if (storageKeys == null || storageKeys.PrimaryKey == null || storageKeys.SecondaryKey == null)
            {
                throw new Exception(string.Format(Resources.ServiceExtensionCannotFindStorageAccountKey, StorageAccountName));
            }
            StorageKey = storageKeys.PrimaryKey != null ? storageKeys.PrimaryKey : storageKeys.SecondaryKey;
        }

        protected void ValidateEndpointSuffix(string endpointSuffix)
        {
            if (!string.IsNullOrEmpty(endpointSuffix))
            {
                StorageEndpointSuffix = endpointSuffix;
            }
        }

        protected void RemoveAntimalwareExtension()
        {
            ProviderNamespace = AntimalwareExtensionProviderNamespace;
            ExtensionName = AntimalwareExtensionName;

            ExtensionConfigurationBuilder configBuilder = ExtensionManager.GetBuilder(Deployment != null ? Deployment.ExtensionConfiguration : null);
            if (UninstallConfiguration && configBuilder.ExistAny(ProviderNamespace, ExtensionName))
            {
                configBuilder.RemoveAny(ProviderNamespace, ExtensionName);
                WriteWarning(string.Format(Resources.ServiceExtensionRemovingFromAllRoles, ExtensionName, ServiceName));
                ChangeDeployment(configBuilder.ToConfiguration());
            }
            else if (configBuilder.Exist(Role, ProviderNamespace, ExtensionName))
            {
                configBuilder.Remove(Role, ProviderNamespace, ExtensionName);
                if (Role == null || !Role.Any())
                {
                    WriteWarning(string.Format(Resources.ServiceExtensionRemovingFromAllRoles, ExtensionName, ServiceName));
                }
                else
                {
                    bool defaultExists = configBuilder.ExistDefault(ProviderNamespace, ExtensionName);
                    foreach (var r in Role)
                    {
                        WriteWarning(string.Format(Resources.ServiceExtensionRemovingFromSpecificRoles, ExtensionName, r, ServiceName));
                        if (defaultExists)
                        {
                            WriteWarning(string.Format(Resources.ServiceExtensionRemovingSpecificAndApplyingDefault, ExtensionName, r));
                        }
                    }
                }

                ChangeDeployment(configBuilder.ToConfiguration());
            }
            else
            {
                WriteWarning(string.Format(Resources.ServiceExtensionNoExistingExtensionsEnabledOnRoles, ProviderNamespace, ExtensionName));
            }
        }

        protected HostedServiceListExtensionsResponse.Extension GetDiagnosticsExtension()
        {
            return (from e in this.ComputeClient.HostedServices.ListExtensions(ServiceName).Extensions
                    where
                        e.ProviderNamespace == AntimalwareDiagnosticsExtensionNamespace
                        && e.Type == AntimalwareDiagnosticsExtensionName
                    select e).FirstOrDefault();
        }

        protected HostedServiceListExtensionsResponse.Extension GetAntimalwareExtension()
        {
            return (from e in this.ComputeClient.HostedServices.ListExtensions(ServiceName).Extensions
                    where
                        e.ProviderNamespace == AntimalwareExtensionProviderNamespace
                        && e.Type == AntimalwareExtensionName
                    select e).FirstOrDefault();
        }

        protected void RemoveExistingAntimalwareMonitoringConfig()
        {
            // this does not remove the diagnostics extension entirely, it only removes the portion of the 
            // diagnostics configuration that monitors antimalware events- everything else will remain 
            // in order to avoid doing harm to any other users who may be sharing the diagnostics extension 

            var ext = GetDiagnosticsExtension();
            if (ext != null)
            {
                string tmpXmlString = ext.PublicConfiguration;
                string AntimalwareDataSourceName = "System!*[System[Provider[@Name='Microsoft Antimalware']]]";
                string DiagnosticsConfigXmlNamespace = @"http://schemas.microsoft.com/ServiceHosting/2010/10/DiagnosticsConfiguration";

                // remove the data source element with the antimalware event provider 
                XmlDocument tmpXmlDoc = new XmlDocument();
                tmpXmlDoc.LoadXml(tmpXmlString);

                // retrieve storage account name from public configuration
                string stgAcctNameXPath = string.Format(@"//*[local-name()='{0}' and namespace-uri()='{1}']", StorageAccountElemStr, DiagnosticsConfigXmlNamespace);
                XmlNode stgAcctNameNode = tmpXmlDoc.DocumentElement.SelectSingleNode(stgAcctNameXPath);
                if (stgAcctNameNode != null)
                {
                    StorageAccountName = stgAcctNameNode.InnerText;
                }
                if (string.IsNullOrWhiteSpace(StorageAccountName))
                {
                    // do not modify diagnostics config without including the storage account
                    // throw terminating exception since it is not possible to preserve the 
                    // existing storage account with the configuration if it doesn't have a  
                    // hint to what the last storage account was in the public configuration 
                    ThrowTerminatingError(new ErrorRecord(
                        new Exception(Resources.ServiceExtensionExistingMonitoringConfigurationIsMissingStorageAccountNameElement),
                        string.Empty,
                        ErrorCategory.InvalidData,
                        null));

                    return;
                }
                else
                {
                    // check the storage account and initialize for use
                    ValidateStorageAccount();
                }

                // locate the antimalware data source node in the document 
                string antimalwareDataSourceXPath = string.Format(@"//*[local-name()='{0}' and @name=""{1}"" and namespace-uri()='{2}']", "DataSource", AntimalwareDataSourceName, DiagnosticsConfigXmlNamespace);
                XmlNode antimalwareDataSourceNode = tmpXmlDoc.DocumentElement.SelectSingleNode(antimalwareDataSourceXPath);
                if (antimalwareDataSourceNode != null)
                {
                    XmlNode windowsEventLogNode = antimalwareDataSourceNode.ParentNode;
                    if (windowsEventLogNode.RemoveChild(antimalwareDataSourceNode) != null)
                    {
                        // remove the windows event log if there are no other child data sources present
                        // as will be required for schema validation to succeed when sending the new config
                        // any other data sources outside of the windows event log are left untouched 
                        if (!windowsEventLogNode.HasChildNodes)
                        {
                            windowsEventLogNode.ParentNode.RemoveChild(windowsEventLogNode);
                        }
                    }

                    // now reinstall the diagnostics extension with the updated configuration
                    InitializeDiagnosticsSettings();
                    ExtensionConfigurationInput diagExtConfigInput = new ExtensionConfigurationInput
                    {
                        ProviderNameSpace = ProviderNamespace,
                        Type = ExtensionName,
                        CertificateThumbprint = CertificateThumbprint,
                        ThumbprintAlgorithm = ThumbprintAlgorithm,
                        X509Certificate = X509Certificate,
                        PublicConfiguration = tmpXmlDoc.OuterXml,
                        PrivateConfiguration = PrivateConfiguration,
                        Roles = new ExtensionRoleList(Role != null && Role.Any() ? Role.Select(r => new ExtensionRole(r)) : Enumerable.Repeat(new ExtensionRole(), 1))
                    };
                    AntimalwareMonitoringExtensionConfigurationInput = diagExtConfigInput;
                }
                else
                {
                    // no existing antimalware data source was found needing removal
                    return;
                }
            }
        }
    }
}
